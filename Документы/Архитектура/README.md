# Архитектура MultiCode (0.1.0-alpha)

## Оглавление
- [Слои системы](#слои-системы)
- [Ядро](#ядро)
  - [Основные объекты](#основные-объекты)
  - [Алгоритмы](#алгоритмы)
- [Сериализация (GraphSerializer)](#сериализация-graphserializer)
- [Генерация кода (что планируется)](#генерация-кода-что-планируется)
- [VS Code Extension](#vs-code-extension)
- [Взаимодействие модулей](#взаимодействие-модулей)
- [Ответственности](#ответственности)
- [Правила соединения портов](#правила-соединения-портов)
- [Ограничения `Port::set_type_name`](#ограничения-portset_type_name)

## Слои системы
1. **Core Library (C++)** — `include/visprog/core`, `src/core`. Реализация узлов, портов, графа, фабрики и типовой системы. Собирается в статическую библиотеку `multicode_core`.
2. **Тестовый рантайм** — `tests/`. Catch2-пакет, который проверяет основные сценарии: фабрика узлов, манипуляции графом, валидация, статистика.
3. **Serialization** — `GraphSerializer` (C++/nlohmann-json) экспортирует/импортирует графы. Codegen остаётся в статусе планов.
4. **VS Code Extension** — есть `package.json` и список npm-зависимостей, но исходники отсутствуют.

## Ядро
### Основные объекты
- `NodeId`, `PortId`, `ConnectionId`, `GraphId` (`Types.hpp`) — строгие типы поверх `uint64_t` + сравнение и хеши.
- `Port` (`Port.hpp/.cpp`) — value-type, хранит направление, тип данных, имя. Метод `can_connect_to` проверяет совместимость (см. раздел «Правила соединения портов»).
- `Node` (`Node.hpp/.cpp`) — владеет портами, метаданными и описанием. ID и тип неизменяемые, остальное меняется под внешняя синхронизацией. `Node::validate` проверяет ограничения для Start, End, PureFunction и т.д.
- `NodeFactory` (`NodeFactory.*`) — единственная точка создания узлов, добавляет стартовые порты и генерирует имена.
- `Graph` (`Graph.*`) — владеет `std::unique_ptr<Node>`, хранит связи, adjacency-списки и метаданные. Предоставляет быстрый доступ по ID, валидацию, топологическую сортировку и статистику.

### Алгоритмы
- **Добавление узла**: проверка уникальности ID, инициализация adjacency.
- **Создание соединения** (`Graph::connect`): проверка существования узлов/портов, направления, типов данных и отсутствия дубликатов.
- **Валидация графа** (`Graph::validate`):
  - Один Start и минимум один End.
  - Все узлы достижимы из Start.
  - Нет незамкнутых execution-циклов.
  - Каждый узел проходит собственную валидацию.
- **Статистика** (`Graph::get_statistics`): количество узлов/связей, разбивка по типам, глубина (максимальная длина execution-цепочки).
- **Утилиты**: поиск Start/End, выборка узлов по типу/имени, проверка наличия пути.

## Сериализация (GraphSerializer)
- **Расположение**: `include/visprog/core/GraphSerializer.hpp`, реализация — `src/core/GraphSerializer.cpp`.
- **API**:
  - `GraphSerializer::to_json(const Graph&)` — детерминированный JSON (graph/nodes/connections).
  - `GraphSerializer::from_json(const nlohmann::json&) -> Result<Graph>` — строго валидирует поля и восстанавливает граф.
- **Заголовок `schema`**: `{ version: "1.0.0", coreMin: "0.1.0-alpha", coreMax: "0.1.x" }`. Без него (или при несовместимых значениях) десериализация завершается ошибкой `606`. Окно версий соответствует текущему ядру (`0.1.0-alpha`), см. обновления статуса в [`Документы/ProjectStatus.md`](../ProjectStatus.md#следующие-шаги).
- **Формат**:
  - `graph`: `{ id: GraphId, name: string, metadata: { key: string } }`.
  - `nodes`: массив объектов с полями `id`, `type`, `name`, `displayName?`, `description?`, `metadata`, `ports`.
  - `ports`: `{ id, name, direction (Input/Output/InOut), dataType (совпадает с to_string(DataType)), typeName? }`.
  - `connections`: `{ id, type (Execution/Data), from: { nodeId, portId }, to: { nodeId, portId } }`.
- **Идентификаторы**: при десериализации синхронизируются счётчики `NodeFactory` и `Port`, а `Graph` принимает готовые `ConnectionId`, чтобы новые узлы/порты не конфликтовали с сохранёнными.
- **Ошибки**: код 60x — проблемы формата (нет поля, неверный тип, некорректный enum), 30x — переиспользование ID/несовместимость портов.
- **Тесты**: `tests/core/test_graph_serializer.cpp` содержит снапшот-проверку (фиксированный JSON ↔ Graph ↔ JSON), round-trip и негативные кейсы.
- **Использование**: VS Code расширение и CLI могут писать/читать JSON один-в-один без post-processing. Для UI достаточно держать согласованный справочник enum-значений.

## Генерация кода (что планируется)
- Интерфейс `ICodeGenerator` с методами `supports(Language)` и `generate(const Graph&, const CodeBinding&)`.
- Первая реализация — `CppCodeGenerator`. Поддерживаем последовательный поток, переменные, If, ForLoop, базовые арифметические узлы.
- Потребуется таблица сопоставления `NodeType -> Template`.
- Выход: структура `{ std::string code; std::vector<Warning> warnings; }`.

## VS Code Extension
- На данный момент есть только `package.json` и конфигурация npm-скриптов.
- MVP-план:
  1. `src/extension.ts` с регистрацией команд и созданием webview.
  2. Webview (React или чистый TS) на Cytoscape + Zustand.
  3. IPC-протокол `graphChanged`, `saveGraph`, `generateCode`.
  4. Интеграция с будущим `GraphSerializer`.

## Взаимодействие модулей
1. Webview хранит структуру графа в JS и отправляет JSON в backend.
2. Расширение зовёт `GraphSerializer::from_json`, передаёт граф в Core.
3. Core валидирует граф и (позже) отдаёт в `ICodeGenerator`.
4. Результат возвращается в webview или записывается в файл через `CodeBinding`.

## Ответственности
- Core не знает про VS Code и JSON.
- Serialization отвечает только за импорт/экспорт.
- Extension управляет UX и IPC.
- Code generation отделён интерфейсом, чтобы можно было добавить Rust/ASM позже.

### Правила соединения портов

| Категория | Правило | Пояснение |
|-----------|---------|-----------|
| Направление | `Output → Input`, `InOut ↔ *` | Соединения возможны только при противоположном направлении. |
| Execution | Только `Execution ↔ Execution` | Потоки управления не смешиваются с данными. |
| Void | `Void` соединяется только с `Void` | Исключает передачу значения и напоминает о явном завершении. |
| Any/Auto | `Any` и `Auto` принимают любые типы | Упрощают создание универсальных узлов и прототипов. |
| Template | Требует совпадения `type_name` или универсального имени (`*`, `void`, `auto`, `any`) | Позволяет согласовывать шаблонные пины. |
| Пользовательские типы | `Struct/Class/Enum` → совпадение `type_name` | Гарантирует точное совпадение пользовательских идентификаторов. |
| Указатели и ссылки | `Pointer/Reference` совместимы при совпадении `type_name` (или универсальном имени) | Поддерживает `T* ↔ T&` и «void*» как универсальный тип. |
| Контейнеры | Совпадение контейнера (`Array/Vector/Map/Set`) и их `type_name` | Предотвращает смешивание коллекций с разными элементами. |
| Числа | Разрешены целочисленные расширения, `int → float/double`, `float → double`, `float ↔ double` | Воспроизводит безопасные неявные преобразования C++. |
| Строки | `String ↔ StringView`, любой тип → `String/StringView` | Ноды приводят данные к строке для логирования и UI. |
| Логические | Любое числовое значение → `Bool` | Соответствует стандартному приведению к булеву. |

**Дополнительно:**

- Пустой `type_name` интерпретируется как универсальный идентификатор внутри своей категории (`Vector`, `Pointer`, шаблоны и т.д.).
- Перед сравнением `type_name` пропускается через нормализующий парсер: он обрезает пробелы, приводит идентификаторы к нижнему регистру, раскладывает шаблонные аргументы и сортирует именованные пары (`key=value`, `value=...`). Благодаря этому `Key=std::string, Value=Vector<int>` и `value=vector< int >, key=STD::STRING` считаются эквивалентными.
- Парсер рекурсивно обрабатывает вложенные контейнеры, поэтому `Vector<Map<std::string, Vector<Game.Item>>>` совместим с `map < std::string , vector<game.item> >` при сопоставлении портов `Vector`.
- Используйте именованные пары для `Map` (например, `key=std::string, value=Vector<int>`) или позиционные аргументы (`std::string, Vector<int>`). Порядок именованных пар значения не имеет, а позиционные аргументы должны идти в фиксированном порядке (сначала ключ, потом значение).
- Поддержка задокументирована и проверяется тестами [`tests/core/test_port.cpp`](../../tests/core/test_port.cpp), обновляйте их при изменении правил.
- Любые архитектурные инициативы по расширению типовой системы фиксируйте в `ROADMAP.md`, чтобы синхронизировать команду.

### Ограничения `Port::set_type_name`

- Метод доступен только для типов, требующих уточнения (`Pointer`, `Reference`, контейнеры, пользовательские, `Template`). Для примитивов и прочих категорий вызов завершится `std::invalid_argument` с указанием проблемного типа.
- Универсальные маркеры (`*`, `void`, `auto`, `any`) допускаются исключительно для указателей/ссылок и шаблонных параметров. Контейнеры и пользовательские типы требуют осмысленных обозначений элементов.
- Все сценарии валидации зафиксированы в тестах раздела «set_type_name validation» (`[tests/core/test_port.cpp](../../tests/core/test_port.cpp)`), обновляйте их синхронно с изменениями логики.
