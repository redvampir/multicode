# Code Binding (Graph ↔ Source)

## Цель
Code Binding нужен, чтобы **вставлять свежий сгенерированный код в существующий `.cpp` файл** без перезаписи всего файла.

Подход: extension ищет специальные маркеры и заменяет **только внутренний сегмент блока**.

## Формат маркеров
```cpp
// multicode:begin <id>
// ...сегмент, который управляется MultiCode...
// multicode:end <id>
```

`<id>` — строковый идентификатор блока, например `main_loop` или `graph-7c9f`.

## Поведение команды «Вставить в файл»

### 1) Выбор файла
- Пользователь запускает binding-режим (из toolbar webview или командой extension).
- Выбирает целевой `.cpp/.cc/.cxx/.hpp/.h` файл.

### 2) Парсинг маркеров
- Extension читает файл и строит список всех `multicode` блоков.
- Парсер проверяет порядок маркеров и валидность пар begin/end.

### 3) Обновление кода
- Если найден один блок → он обновляется сразу.
- Если найдено несколько блоков:
  - сначала можно указать `id` (фильтрация),
  - затем (если осталось несколько) выбрать нужный блок по контексту в QuickPick.
- Обновление делает замену **только между begin/end**, остальной файл остаётся без изменений.

## Безопасные сценарии

### Маркеры отсутствуют
Если в файле нет ни одного `multicode` блока:
1. Показывается предложение добавить новый блок в конец файла.
2. Пользователь вводит `id` блока.
3. В конец файла вставляется:
   - `// multicode:begin <id>`
   - свежий сгенерированный код
   - `// multicode:end <id>`

### Несколько блоков
- Выбор выполняется по `id` и/или по контексту (строки и preview содержимого).
- Это предотвращает случайную перезапись чужого блока.

### Некорректный порядок маркеров
Обработка как ошибка (без записи в файл):
- `end` без `begin`,
- вложенный `begin` до закрытия текущего,
- `begin` без `end`,
- несовпадающие `id` у begin/end.

Пользователь получает сообщение об ошибке с номером строки.

## Ограничения текущей реализации
- Binding работает по текстовым маркерам, **без AST-анализа C++**.
- Вложенные `multicode`-блоки не поддерживаются.
- Если при множественных блоках `id` не указан, возможен ручной выбор через QuickPick.
- Маркеры и их структура считаются частью контракта; ручное повреждение маркеров блокирует автоматическое обновление.

## Короткий пример
**До**:
```cpp
void tick() {
  // multicode:begin main_loop
  std::cout << "old" << std::endl;
  // multicode:end main_loop
}
```

**После binding-обновления**:
```cpp
void tick() {
  // multicode:begin main_loop
  std::cout << "fresh" << std::endl;
  // multicode:end main_loop
}
```
