// Copyright (c) 2025 МультиКод Team. MIT License.

#include "visprog/generators/CppCodeGenerator.hpp"
#include "visprog/core/Graph.hpp"
#include "visprog/core/Node.hpp"
#include "visprog/core/Port.hpp"
#include "visprog/core/Types.hpp"

#include <memory>
#include <sstream>
#include <stdexcept>

namespace visprog::generators {

// Helper to find the start node
const core::Node* find_start_node(const core::Graph& graph) {
    for (const auto& node : graph.get_nodes()) {
        if (node->get_type().name == core::NodeTypes::Start.name) {
            return node.get();
        }
    }
    return nullptr;
}

// Helper to trace the next node in the execution path
const core::Node* get_next_node(const core::Graph& graph, const core::Node& current_node) {
    // Find the output execution port
    const auto* output_exec_port = current_node.find_first_port_by_type(core::DataType::Execution, core::PortDirection::Output);
    if (!output_exec_port) {
        return nullptr; // End of path
    }

    // Find the connection from this port
    const auto* connection = graph.find_connection_from(output_exec_port->id);
    if (!connection) {
        return nullptr; // Unconnected path
    }

    // Find the target node
    return graph.get_node_by_id(connection->end_node_id);
}


auto CppCodeGenerator::generate(const core::Graph& graph) -> core::Result<std::string> {
    std::stringstream ss;

    // 1. Add headers
    ss << "// Generated by MultiCode C++ Code Generator\n";
    ss << "#include <iostream>\n";
    ss << "#include <string>\n\n";

    // 2. Find the start node
    const auto* start_node = find_start_node(graph);
    if (!start_node) {
        return core::Result<std::string>{core::Error{"Graph must have a Start node."}};
    }

    // 3. Main function definition
    ss << "int main() {\n";

    // 4. Traverse the graph and generate code
    const core::Node* current_node = start_node;
    while (current_node) {
        const auto type = current_node->get_type();

        if (type.name == core::NodeTypes::PrintString.name) {
            // For PrintString, get the value from the property
            try {
                auto value = std::any_cast<std::string>(current_node->get_property("value"));
                ss << "    std::cout << \"" << value << "\" << std::endl;\n";
            } catch (const std::bad_any_cast& e) {
                 return core::Result<std::string>{core::Error{"Invalid property type for PrintString value."}};
            }

        } else if (type.name == core::NodeTypes::End.name) {
            // The End node marks the exit point
            ss << "    return 0;\n";
        }

        // Move to the next node in the execution flow
        current_node = get_next_node(graph, *current_node);
    }

    ss << "}\n";

    return core::Result<std::string>{ss.str()};
}

}  // namespace visprog::generators
