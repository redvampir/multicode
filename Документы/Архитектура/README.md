# Архитектура MultiCode (0.1.0-alpha)

## Слои системы
1. **Core Library (C++)** — `include/visprog/core`, `src/core`. Реализация узлов, портов, графа, фабрики и типовой системы. Собирается в статическую библиотеку `multicode_core`.
2. **Тестовый рантайм** — `tests/`. Catch2-пакет, который проверяет основные сценарии: фабрика узлов, манипуляции графом, валидация, статистика.
3. **Serialization и Codegen** — пока отсутствуют. В репозитории нет JSON-формата и генератора кода; ниже задокументирован только план.
4. **VS Code Extension** — есть `package.json` и список npm-зависимостей, но исходники отсутствуют.

## Ядро
### Основные объекты
- `NodeId`, `PortId`, `ConnectionId`, `GraphId` (`Types.hpp`) — строгие типы поверх `uint64_t` + сравнение и хеши.
- `Port` (`Port.hpp/.cpp`) — value-type, хранит направление, тип данных, имя. Метод `can_connect_to` проверяет совместимость.
- `Node` (`Node.hpp/.cpp`) — владеет портами, метаданными и описанием. ID и тип неизменяемые, остальное меняется под внешняя синхронизацией. `Node::validate` проверяет ограничения для Start, End, PureFunction и т.д.
- `NodeFactory` (`NodeFactory.*`) — единственная точка создания узлов, добавляет стартовые порты и генерирует имена.
- `Graph` (`Graph.*`) — владеет `std::unique_ptr<Node>`, хранит связи, adjacency-списки и метаданные. Предоставляет быстрый доступ по ID, валидацию, топологическую сортировку и статистику.

### Алгоритмы
- **Добавление узла**: проверка уникальности ID, инициализация adjacency.
- **Создание соединения** (`Graph::connect`): проверка существования узлов/портов, направления, типов данных и отсутствия дубликатов.
- **Валидация графа** (`Graph::validate`):
  - Один Start и минимум один End.
  - Все узлы достижимы из Start.
  - Нет незамкнутых execution-циклов.
  - Каждый узел проходит собственную валидацию.
- **Статистика** (`Graph::get_statistics`): количество узлов/связей, разбивка по типам, глубина (максимальная длина execution-цепочки).
- **Утилиты**: поиск Start/End, выборка узлов по типу/имени, проверка наличия пути.

## Сериализация (что нужно сделать)
- Формат: JSON (nlohmann-json уже в зависимостях).
- Структура: объект графа (`id`, `name`, `metadata`) + массив узлов (с портами и метаданными) + массив соединений.
- API: `GraphSerializer::to_json(const Graph&)` и `GraphSerializer::from_json(const nlohmann::json&) -> Result<Graph>`.
- Тесты: снапшоты с заранее подготовленными графами.

## Генерация кода (что планируется)
- Интерфейс `ICodeGenerator` с методами `supports(Language)` и `generate(const Graph&, const CodeBinding&)`.
- Первая реализация — `CppCodeGenerator`. Поддерживаем последовательный поток, переменные, If, ForLoop, базовые арифметические узлы.
- Потребуется таблица сопоставления `NodeType -> Template`.
- Выход: структура `{ std::string code; std::vector<Warning> warnings; }`.

## VS Code Extension
- На данный момент есть только `package.json` и конфигурация npm-скриптов.
- MVP-план:
  1. `src/extension.ts` с регистрацией команд и созданием webview.
  2. Webview (React или чистый TS) на Cytoscape + Zustand.
  3. IPC-протокол `graphChanged`, `saveGraph`, `generateCode`.
  4. Интеграция с будущим `GraphSerializer`.

## Взаимодействие модулей
1. Webview хранит структуру графа в JS и отправляет JSON в backend.
2. Расширение зовёт `GraphSerializer::from_json`, передаёт граф в Core.
3. Core валидирует граф и (позже) отдаёт в `ICodeGenerator`.
4. Результат возвращается в webview или записывается в файл через `CodeBinding`.

## Ответственности
- Core не знает про VS Code и JSON.
- Serialization отвечает только за импорт/экспорт.
- Extension управляет UX и IPC.
- Code generation отделён интерфейсом, чтобы можно было добавить Rust/ASM позже.
