import type { GraphState, GraphEdge } from './graphState';

export const generateCodeFromGraph = (state: GraphState): string => {
  const order = getExecutionOrder(state);
  const lines: string[] = [];

  lines.push('// Generated by MultiCode');
  lines.push(`// Graph: ${state.name}`);
  lines.push('');

  if (state.language === 'cpp') {
    lines.push('#include <iostream>');
    lines.push('');
    lines.push('int main() {');
  } else if (state.language === 'rust') {
    lines.push('fn main() {');
  } else {
    lines.push('int main() {');
  }

  if (!order.length) {
    lines.push('    // TODO: empty graph');
  } else {
    order.forEach((nodeId) => {
      const node = state.nodes.find((n) => n.id === nodeId);
      if (!node) {
        return;
      }
      switch (node.type) {
        case 'Start':
          lines.push(`    // Start: ${node.label}`);
          break;
        case 'End':
          lines.push(`    // End: ${node.label}`);
          lines.push('    return 0;');
          break;
        case 'Function':
          lines.push(`    // Function: ${node.label}`);
          lines.push(`    // TODO: call ${node.label}();`);
          break;
        case 'Variable':
          lines.push(`    // Variable: ${node.label}`);
          lines.push(`    int ${sanitizeIdentifier(node.label)} = 0;`);
          break;
        default:
          lines.push(`    // ${node.type}: ${node.label}`);
          break;
      }
    });
  }

  lines.push('}');
  lines.push('');
  return lines.join('\n');
};

const getExecutionOrder = (state: GraphState): string[] => {
  const adj = new Map<string, GraphEdge[]>();
  state.edges
    .filter((edge) => edge.kind !== 'data')
    .forEach((edge) => {
      const list = adj.get(edge.source) ?? [];
      list.push(edge);
      adj.set(edge.source, list);
    });

  const visited = new Set<string>();
  const order: string[] = [];

  const startNodes = state.nodes.filter((node) => node.type === 'Start');
  const entry = startNodes.length ? startNodes[0].id : state.nodes[0]?.id;

  if (!entry) {
    return [];
  }

  const dfs = (nodeId: string): void => {
    if (visited.has(nodeId)) {
      return;
    }
    visited.add(nodeId);
    order.push(nodeId);
    const nextEdges = adj.get(nodeId) ?? [];
    nextEdges.forEach((edge) => dfs(edge.target));
  };

  dfs(entry);
  return order;
};

const sanitizeIdentifier = (label: string): string =>
  label
    .trim()
    .replace(/\s+/g, '_')
    .replace(/[^a-zA-Z0-9_]/g, '')
    .toLowerCase();
