/**
 * Тесты для shared/codegen.ts
 * 
 * Проверяет legacy генерацию кода из GraphState
 */

import { describe, it, expect } from 'vitest';
import { generateCodeFromGraph } from './codegen';
import type { GraphState, GraphNode, GraphEdge, GraphNodeType, GraphEdgeKind } from './graphState';

/**
 * Создать тестовый GraphState
 */
function createGraphState(
  nodes: GraphNode[],
  edges: GraphEdge[] = [],
  options: Partial<GraphState> = {}
): GraphState {
  return {
    id: 'test-graph',
    name: 'Test Graph',
    language: 'cpp',
    displayLanguage: 'ru',
    nodes,
    edges,
    updatedAt: new Date().toISOString(),
    ...options,
  };
}

/**
 * Создать тестовый узел
 */
function createGraphNode(
  type: GraphNodeType,
  label: string,
  id: string
): GraphNode {
  return {
    id,
    type,
    label,
    position: { x: 0, y: 0 },
  };
}

/**
 * Создать тестовое ребро
 */
function createGraphEdge(
  source: string,
  target: string,
  kind: GraphEdgeKind = 'execution'
): GraphEdge {
  return {
    id: `${source}-${target}`,
    source,
    target,
    kind,
  };
}

describe('generateCodeFromGraph', () => {
  describe('Basic generation', () => {
    it('should generate code header with graph name', () => {
      const state = createGraphState([
        createGraphNode('Start', 'Начало', 'start'),
      ], [], { name: 'MyProgram' });
      
      const code = generateCodeFromGraph(state);
      
      expect(code).toContain('// Generated by MultiCode');
      expect(code).toContain('// Graph: MyProgram');
    });
    
    it('should generate main() for cpp language', () => {
      const state = createGraphState([
        createGraphNode('Start', 'Начало', 'start'),
      ], [], { language: 'cpp' });
      
      const code = generateCodeFromGraph(state);
      
      expect(code).toContain('#include <iostream>');
      expect(code).toContain('int main() {');
      expect(code).toContain('}');
    });
    
    it('should generate fn main() for rust language', () => {
      const state = createGraphState([
        createGraphNode('Start', 'Начало', 'start'),
      ], [], { language: 'rust' });
      
      const code = generateCodeFromGraph(state);
      
      expect(code).toContain('fn main() {');
      expect(code).toContain('}');
    });
    
    it('should default to int main() for unknown language', () => {
      const state = createGraphState([
        createGraphNode('Start', 'Начало', 'start'),
      ], [], { language: 'asm' });
      
      const code = generateCodeFromGraph(state);
      
      expect(code).toContain('int main() {');
    });
    
    it('should generate TODO comment for empty graph', () => {
      const state = createGraphState([]);
      
      const code = generateCodeFromGraph(state);
      
      expect(code).toContain('// TODO: empty graph');
    });
  });
  
  describe('Node processing', () => {
    it('should generate Start node comment', () => {
      const state = createGraphState([
        createGraphNode('Start', 'Начало', 'start'),
      ]);
      
      const code = generateCodeFromGraph(state);
      
      expect(code).toContain('// Start: Начало');
    });
    
    it('should generate End node with return 0', () => {
      const state = createGraphState([
        createGraphNode('Start', 'Начало', 'start'),
        createGraphNode('End', 'Конец', 'end'),
      ], [
        createGraphEdge('start', 'end'),
      ]);
      
      const code = generateCodeFromGraph(state);
      
      expect(code).toContain('// End: Конец');
      expect(code).toContain('return 0;');
    });
    
    it('should generate Function node with TODO', () => {
      const state = createGraphState([
        createGraphNode('Start', 'Начало', 'start'),
        createGraphNode('Function', 'ВычислитьСумму', 'func'),
      ], [
        createGraphEdge('start', 'func'),
      ]);
      
      const code = generateCodeFromGraph(state);
      
      expect(code).toContain('// Function: ВычислитьСумму');
      expect(code).toContain('// TODO: call ВычислитьСумму();');
    });
    
    it('should generate Variable node with int declaration', () => {
      const state = createGraphState([
        createGraphNode('Start', 'Начало', 'start'),
        createGraphNode('Variable', 'counter', 'var'),
      ], [
        createGraphEdge('start', 'var'),
      ]);
      
      const code = generateCodeFromGraph(state);
      
      expect(code).toContain('// Variable: counter');
      expect(code).toContain('int');
    });
    
    it('should generate generic comment for Custom node type', () => {
      const state = createGraphState([
        createGraphNode('Start', 'Начало', 'start'),
        createGraphNode('Custom', 'MyCustom', 'custom'),
      ], [
        createGraphEdge('start', 'custom'),
      ]);
      
      const code = generateCodeFromGraph(state);
      
      expect(code).toContain('// Custom: MyCustom');
    });
  });
  
  describe('Execution order (DFS)', () => {
    it('should follow execution edges in correct order', () => {
      const state = createGraphState([
        createGraphNode('Start', 'Начало', 'start'),
        createGraphNode('Variable', 'A', 'var-a'),
        createGraphNode('Variable', 'B', 'var-b'),
        createGraphNode('End', 'Конец', 'end'),
      ], [
        createGraphEdge('start', 'var-a'),
        createGraphEdge('var-a', 'var-b'),
        createGraphEdge('var-b', 'end'),
      ]);
      
      const code = generateCodeFromGraph(state);
      
      // Проверяем порядок появления в коде
      const startIdx = code.indexOf('// Start: Начало');
      const varAIdx = code.indexOf('// Variable: A');
      const varBIdx = code.indexOf('// Variable: B');
      const endIdx = code.indexOf('// End: Конец');
      
      expect(startIdx).toBeLessThan(varAIdx);
      expect(varAIdx).toBeLessThan(varBIdx);
      expect(varBIdx).toBeLessThan(endIdx);
    });
    
    it('should ignore data edges when determining execution order', () => {
      const state = createGraphState([
        createGraphNode('Start', 'Начало', 'start'),
        createGraphNode('Variable', 'X', 'var-x'),
        createGraphNode('End', 'Конец', 'end'),
      ], [
        createGraphEdge('start', 'end', 'execution'),
        createGraphEdge('var-x', 'end', 'data'),
      ]);
      
      const code = generateCodeFromGraph(state);
      
      // var-x не должен быть в execution path
      expect(code).toContain('// Start: Начало');
      expect(code).toContain('// End: Конец');
    });
    
    it('should handle branching execution paths', () => {
      const state = createGraphState([
        createGraphNode('Start', 'Начало', 'start'),
        createGraphNode('Variable', 'Left', 'var-left'),
        createGraphNode('Variable', 'Right', 'var-right'),
      ], [
        createGraphEdge('start', 'var-left'),
        createGraphEdge('start', 'var-right'),
      ]);
      
      const code = generateCodeFromGraph(state);
      
      // Оба узла должны быть обработаны (DFS порядок)
      expect(code).toContain('// Variable: Left');
      expect(code).toContain('// Variable: Right');
    });
    
    it('should handle graph with no edges', () => {
      const state = createGraphState([
        createGraphNode('Start', 'Начало', 'start'),
        createGraphNode('Variable', 'Orphan', 'orphan'),
      ]);
      
      const code = generateCodeFromGraph(state);
      
      // Только start node должен быть обработан (он entry point)
      expect(code).toContain('// Start: Начало');
    });
    
    it('should avoid infinite loops with cyclic graphs', () => {
      const state = createGraphState([
        createGraphNode('Start', 'Начало', 'start'),
        createGraphNode('Variable', 'Loop', 'loop'),
      ], [
        createGraphEdge('start', 'loop'),
        createGraphEdge('loop', 'start'),
      ]);
      
      const code = generateCodeFromGraph(state);
      
      // Should complete without infinite loop
      expect(code).toContain('// Start: Начало');
      expect(code).toContain('// Variable: Loop');
    });
  });
  
  describe('sanitizeIdentifier', () => {
    it('should sanitize variable names with spaces', () => {
      const state = createGraphState([
        createGraphNode('Start', 'Начало', 'start'),
        createGraphNode('Variable', 'my variable', 'var'),
      ], [
        createGraphEdge('start', 'var'),
      ]);
      
      const code = generateCodeFromGraph(state);
      
      expect(code).toContain('my_variable');
    });
    
    it('should sanitize variable names with special characters', () => {
      const state = createGraphState([
        createGraphNode('Start', 'Начало', 'start'),
        createGraphNode('Variable', 'test@123!', 'var'),
      ], [
        createGraphEdge('start', 'var'),
      ]);
      
      const code = generateCodeFromGraph(state);
      
      expect(code).toContain('test123');
    });
    
    it('should convert to lowercase', () => {
      const state = createGraphState([
        createGraphNode('Start', 'Начало', 'start'),
        createGraphNode('Variable', 'MyVariable', 'var'),
      ], [
        createGraphEdge('start', 'var'),
      ]);
      
      const code = generateCodeFromGraph(state);
      
      expect(code).toContain('myvariable');
    });
    
    it('should handle leading/trailing whitespace', () => {
      const state = createGraphState([
        createGraphNode('Start', 'Начало', 'start'),
        createGraphNode('Variable', '  spaced  ', 'var'),
      ], [
        createGraphEdge('start', 'var'),
      ]);
      
      const code = generateCodeFromGraph(state);
      
      expect(code).toContain('spaced');
    });
  });
  
  describe('Edge cases', () => {
    it('should handle empty nodes array', () => {
      const state = createGraphState([]);
      
      const code = generateCodeFromGraph(state);
      
      expect(code).toContain('int main()');
      expect(code).toContain('// TODO: empty graph');
    });
    
    it('should handle node not found in graph', () => {
      const state = createGraphState([
        createGraphNode('Start', 'Начало', 'start'),
      ], [
        createGraphEdge('start', 'nonexistent'),
      ]);
      
      const code = generateCodeFromGraph(state);
      
      // Should not crash
      expect(code).toContain('// Start: Начало');
    });
    
    it('should use first node as entry if no Start node', () => {
      const state = createGraphState([
        createGraphNode('Variable', 'First', 'first'),
        createGraphNode('Variable', 'Second', 'second'),
      ], [
        createGraphEdge('first', 'second'),
      ]);
      
      const code = generateCodeFromGraph(state);
      
      expect(code).toContain('// Variable: First');
      expect(code).toContain('// Variable: Second');
    });
    
    it('should prefer Start node even if not first in array', () => {
      const state = createGraphState([
        createGraphNode('Variable', 'First', 'first'),
        createGraphNode('Start', 'Начало', 'start'),
        createGraphNode('End', 'Конец', 'end'),
      ], [
        createGraphEdge('start', 'end'),
      ]);
      
      const code = generateCodeFromGraph(state);
      
      // Start should be processed, not first variable
      expect(code).toContain('// Start: Начало');
      expect(code).toContain('// End: Конец');
    });
  });
});
