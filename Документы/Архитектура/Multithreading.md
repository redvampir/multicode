# Многопоточность: что есть на самом деле

## Гарантии ядра
- `Port` - полностью неизменяемый после создания, thread-safe.
- `Node` - чтение thread-safe, но любые мутации (добавление портов, метаданных) требуют внешней синхронизации. В коде нигде не используются мьютексы.
- `Graph` - **не потокобезопасен**. Добавление/удаление узлов и соединений, валидация и запросы делят общее состояние (`nodes_`, `connections_`, adjacency). Нужен глобальный mutex/reader-writer lock на стороне вызывающего кода.

## Где реально нужны потоки
1. **VS Code extension** - UI (JS) и backend (C++/WASM) будут общаться через сообщения, поэтому внутри ядра можно остаться на single-thread.
2. **Кодогенерация** - потенциально можно распараллеливать шаблоны, но пока нет смысла.
3. **Сериализация** - чтение/запись файлов происходит синхронно, нагрузка маленькая.

## Что стоит сделать позже
- Обернуть `Graph` во внешнюю оболочку `GraphController`, которая предоставляет `std::shared_mutex` и RAII-локи для операций чтения/записи.
- Добавить санитайзер-тесты (TSAN) в CI, когда появится параллельное использование.
- Перевести генерацию `PortId/NodeId` на атомики (у `Port` уже так, у `NodeFactory` используется `std::atomic_uint64_t` - этого достаточно).

## Итог
Оставляем ядро single-threaded. Вся синхронизация - ответственность уровня, который вызывает API. Документация теперь честно предупреждает об этом, чтобы никто не пытался параллельно модифицировать граф без локов.
