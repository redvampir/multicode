# Архитектура MultiCode (0.1.0-alpha)

## Слои системы
1. **Core Library (C++)** — `include/visprog/core`, `src/core`. Реализация узлов, портов, графа, фабрики и типовой системы. Собирается в статическую библиотеку `multicode_core`.
2. **Тестовый рантайм** — `tests/`. Catch2-пакет, который проверяет основные сценарии: фабрика узлов, манипуляции графом, валидация, статистика.
3. **Serialization и Codegen** — пока отсутствуют. В репозитории нет JSON-формата и генератора кода; ниже задокументирован только план.
4. **VS Code Extension** — есть `package.json` и список npm-зависимостей, но исходники отсутствуют.

## Ядро
### Основные объекты
- `NodeId`, `PortId`, `ConnectionId`, `GraphId` (`Types.hpp`) — строгие типы поверх `uint64_t` + сравнение и хеши.
- `Port` (`Port.hpp/.cpp`) — value-type, хранит направление, тип данных, имя. Метод `can_connect_to` проверяет совместимость (см. раздел «Правила соединения портов»).
- `Node` (`Node.hpp/.cpp`) — владеет портами, метаданными и описанием. ID и тип неизменяемые, остальное меняется под внешняя синхронизацией. `Node::validate` проверяет ограничения для Start, End, PureFunction и т.д.
- `NodeFactory` (`NodeFactory.*`) — единственная точка создания узлов, добавляет стартовые порты и генерирует имена.
- `Graph` (`Graph.*`) — владеет `std::unique_ptr<Node>`, хранит связи, adjacency-списки и метаданные. Предоставляет быстрый доступ по ID, валидацию, топологическую сортировку и статистику.

### Алгоритмы
- **Добавление узла**: проверка уникальности ID, инициализация adjacency.
- **Создание соединения** (`Graph::connect`): проверка существования узлов/портов, направления, типов данных и отсутствия дубликатов.
- **Валидация графа** (`Graph::validate`):
  - Один Start и минимум один End.
  - Все узлы достижимы из Start.
  - Нет незамкнутых execution-циклов.
  - Каждый узел проходит собственную валидацию.
- **Статистика** (`Graph::get_statistics`): количество узлов/связей, разбивка по типам, глубина (максимальная длина execution-цепочки).
- **Утилиты**: поиск Start/End, выборка узлов по типу/имени, проверка наличия пути.

## Сериализация (что нужно сделать)
- Формат: JSON (nlohmann-json уже в зависимостях).
- Структура: объект графа (`id`, `name`, `metadata`) + массив узлов (с портами и метаданными) + массив соединений.
- API: `GraphSerializer::to_json(const Graph&)` и `GraphSerializer::from_json(const nlohmann::json&) -> Result<Graph>`.
- Тесты: снапшоты с заранее подготовленными графами.

## Генерация кода (что планируется)
- Интерфейс `ICodeGenerator` с методами `supports(Language)` и `generate(const Graph&, const CodeBinding&)`.
- Первая реализация — `CppCodeGenerator`. Поддерживаем последовательный поток, переменные, If, ForLoop, базовые арифметические узлы.
- Потребуется таблица сопоставления `NodeType -> Template`.
- Выход: структура `{ std::string code; std::vector<Warning> warnings; }`.

## VS Code Extension
- На данный момент есть только `package.json` и конфигурация npm-скриптов.
- MVP-план:
  1. `src/extension.ts` с регистрацией команд и созданием webview.
  2. Webview (React или чистый TS) на Cytoscape + Zustand.
  3. IPC-протокол `graphChanged`, `saveGraph`, `generateCode`.
  4. Интеграция с будущим `GraphSerializer`.

## Взаимодействие модулей
1. Webview хранит структуру графа в JS и отправляет JSON в backend.
2. Расширение зовёт `GraphSerializer::from_json`, передаёт граф в Core.
3. Core валидирует граф и (позже) отдаёт в `ICodeGenerator`.
4. Результат возвращается в webview или записывается в файл через `CodeBinding`.

## Ответственности
- Core не знает про VS Code и JSON.
- Serialization отвечает только за импорт/экспорт.
- Extension управляет UX и IPC.
- Code generation отделён интерфейсом, чтобы можно было добавить Rust/ASM позже.

### Правила соединения портов

| Категория | Правило | Пояснение |
|-----------|---------|-----------|
| Направление | `Output → Input`, `InOut ↔ *` | Соединения возможны только при противоположном направлении. |
| Execution | Только `Execution ↔ Execution` | Потоки управления не смешиваются с данными. |
| Void | `Void` соединяется только с `Void` | Исключает передачу значения и напоминает о явном завершении. |
| Any/Auto | `Any` и `Auto` принимают любые типы | Упрощают создание универсальных узлов и прототипов. |
| Template | Требует совпадения `type_name` или универсального имени (`*`, `void`, `auto`, `any`) | Позволяет согласовывать шаблонные пины. |
| Пользовательские типы | `Struct/Class/Enum` → совпадение `type_name` | Гарантирует точное совпадение пользовательских идентификаторов. |
| Указатели и ссылки | `Pointer/Reference` совместимы при совпадении `type_name` (или универсальном имени) | Поддерживает `T* ↔ T&` и «void*» как универсальный тип. |
| Контейнеры | Совпадение контейнера (`Array/Vector/Map/Set`) и их `type_name` | Предотвращает смешивание коллекций с разными элементами. |
| Числа | Разрешены целочисленные расширения, `int → float/double`, `float → double`, `float ↔ double` | Воспроизводит безопасные неявные преобразования C++. |
| Строки | `String ↔ StringView`, любой тип → `String/StringView` | Ноды приводят данные к строке для логирования и UI. |
| Логические | Любое числовое значение → `Bool` | Соответствует стандартному приведению к булеву. |

**Дополнительно:**

- Пустой `type_name` интерпретируется как универсальный идентификатор внутри своей категории (`Vector`, `Pointer`, шаблоны и т.д.).
- Перед сравнением `type_name` пропускается через нормализующий парсер: он обрезает пробелы, приводит идентификаторы к нижнему регистру, раскладывает шаблонные аргументы и сортирует именованные пары (`key=value`, `value=...`). Благодаря этому `Key=std::string, Value=Vector<int>` и `value=vector< int >, key=STD::STRING` считаются эквивалентными.
- Парсер рекурсивно обрабатывает вложенные контейнеры, поэтому `Vector<Map<std::string, Vector<Game.Item>>>` совместим с `map < std::string , vector<game.item> >` при сопоставлении портов `Vector`.
- Используйте именованные пары для `Map` (например, `key=std::string, value=Vector<int>`) или позиционные аргументы (`std::string, Vector<int>`). Порядок именованных пар значения не имеет, а позиционные аргументы должны идти в фиксированном порядке (сначала ключ, потом значение).
- Поддержка задокументирована и проверяется тестами [`tests/core/test_port.cpp`](../../tests/core/test_port.cpp), обновляйте их при изменении правил.
- Любые архитектурные инициативы по расширению типовой системы фиксируйте в `ROADMAP.md`, чтобы синхронизировать команду.

### Ограничения `Port::set_type_name`

- Метод доступен только для типов, требующих уточнения (`Pointer`, `Reference`, контейнеры, пользовательские, `Template`). Для примитивов и прочих категорий вызов завершится `std::invalid_argument` с указанием проблемного типа.
- Универсальные маркеры (`*`, `void`, `auto`, `any`) допускаются исключительно для указателей/ссылок и шаблонных параметров. Контейнеры и пользовательские типы требуют осмысленных обозначений элементов.
- Все сценарии валидации зафиксированы в тестах раздела «set_type_name validation» (`[tests/core/test_port.cpp](../../tests/core/test_port.cpp)`), обновляйте их синхронно с изменениями логики.
